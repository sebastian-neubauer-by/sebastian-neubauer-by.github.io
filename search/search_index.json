{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DevCon Workshop: Platform at Your Fingertips Registration Note If you want to participate in the workshop, you need an account first. Please create your account well in advance as your request needs to be checked. You can request your account here Click on 'Register Here' Make sure you fill out all the required fields Make sure you fill out all the required fields and make sure it is a valid phone number (you can check here ). Also make sure to use your company email address. Otherwise the approval might fail. If you do not receive an email within 24h (manual approval required), please contact Sebastian.Neubauer@[Blue Yonder domain] Once you received an email with a temporary password. You can now login here (and change your password on your first login): https://bylumuiportalplpna.azureedge.net/home/ You need to enter the realm, which is by-developer for the developer portal. That's it, you should now be onboarded to the Luminate Platform! Prepwork for the workshop Create your account All you need is a Browser (use Firefox or Chrome) and internet","title":"Registration"},{"location":"#welcome-to-devcon","text":"","title":"Welcome to DevCon"},{"location":"#workshop-platform-at-your-fingertips","text":"","title":"Workshop: Platform at Your Fingertips"},{"location":"#registration","text":"Note If you want to participate in the workshop, you need an account first. Please create your account well in advance as your request needs to be checked. You can request your account here Click on 'Register Here' Make sure you fill out all the required fields Make sure you fill out all the required fields and make sure it is a valid phone number (you can check here ). Also make sure to use your company email address. Otherwise the approval might fail. If you do not receive an email within 24h (manual approval required), please contact Sebastian.Neubauer@[Blue Yonder domain] Once you received an email with a temporary password. You can now login here (and change your password on your first login): https://bylumuiportalplpna.azureedge.net/home/ You need to enter the realm, which is by-developer for the developer portal. That's it, you should now be onboarded to the Luminate Platform! Prepwork for the workshop Create your account All you need is a Browser (use Firefox or Chrome) and internet","title":"Registration"},{"location":"introduction/","text":"Introduction","title":"Introduction"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"story/","text":"The Story The Products In our Blue Yonder products portfolio we have two products that are tightly coupled to one each other. It is Luminate Demand Edge (LDE), our demand forecasting solution for Retail and Luminate Store Fulfilment (LSF), our solution to automated and optimized orders based on demand predictions. LSF takes the demand predictions of LSF and turns them into order proposals using sophisticated algorithms. In LDE, the customer is able to override the demand predictions generated by LDE and LSF would pickup those overridden demand predicitons automatically. The Override Prediction Incident CC BY-SA 3.0 Daniel Case James is a supply chain specialist working at one of Blue yonder's customer, a grocery store and is responsible for the LSF product. Today, James has a very bad day, all shelves are empty in one of the stores. That's not good. But happened? It turns out, there is a big festival happeing next to this store. It turns out, Susan, a demand specialist working at the same customer but responsible for the demand predictions of LDE product indeed adjusted the demands using predictions overrides. But why were the orders not adjusted as well? LSF typically run at fixed daily schedules and if the prediction overrides are created after the LSF run already processed for the day, the predictions overrides will only be picked up at the next run which in this case was too late. James, who has some basic knowledge of programming, decides to use the extensibility features of the Luminate Platform and build a notification mechanism. This will help him to prevent any of these kind of incidents in the future. Let's help James and build this feature together with him!","title":"The Story"},{"location":"story/#the-story","text":"","title":"The Story"},{"location":"story/#the-products","text":"In our Blue Yonder products portfolio we have two products that are tightly coupled to one each other. It is Luminate Demand Edge (LDE), our demand forecasting solution for Retail and Luminate Store Fulfilment (LSF), our solution to automated and optimized orders based on demand predictions. LSF takes the demand predictions of LSF and turns them into order proposals using sophisticated algorithms. In LDE, the customer is able to override the demand predictions generated by LDE and LSF would pickup those overridden demand predicitons automatically.","title":"The Products"},{"location":"story/#the-override-prediction-incident","text":"CC BY-SA 3.0 Daniel Case James is a supply chain specialist working at one of Blue yonder's customer, a grocery store and is responsible for the LSF product. Today, James has a very bad day, all shelves are empty in one of the stores. That's not good. But happened? It turns out, there is a big festival happeing next to this store. It turns out, Susan, a demand specialist working at the same customer but responsible for the demand predictions of LDE product indeed adjusted the demands using predictions overrides. But why were the orders not adjusted as well? LSF typically run at fixed daily schedules and if the prediction overrides are created after the LSF run already processed for the day, the predictions overrides will only be picked up at the next run which in this case was too late. James, who has some basic knowledge of programming, decides to use the extensibility features of the Luminate Platform and build a notification mechanism. This will help him to prevent any of these kind of incidents in the future. Let's help James and build this feature together with him!","title":"The Override Prediction Incident"},{"location":"workshop-walkthrough/","text":"The developer Portal Login First we login into the developer portal: https://bylumuiportalplpna.azureedge.net/home/ You need to enter the realm, which is by-developer for the developer portal. Then login with your account credentials. Navigate the portal After login you see the dashboard For now we are only interested in the \"App Gallery\" whoch shows all services and application that you have access to. The App Gallery view The API Catalog We now want to find out if there are APIs we can use to build our notification feature. For this we launch the API Catalog in the API Gallery Launch the API Catalog Inside the API Catalog, search for LDE. You then will find all the API exposed by LDE for you. You should find the \"Blue Yonder LDE Prediction Overrides v1\" API and click on it. Finding the LDE Prediction Overrides API in the API Catalog Once you clicked on it, you will be navigated to the API documentation. Documentation of the LDE Prediction Overrides API Here you can try our an API call by first clicking on the \"Try it out\" button and subsequently on the \"Execute\" button. You can try the API by clicking on \"Execute\" By exectuing this GET request we will get a list of all prediction overrides stored in the LDE instance. Hey, we have a list of all prediction overrides stored in the LDE instance! The response should look like this [ { \"processing_status\" : \"FINISHED\" , \"override_id\" : \"6caccdf4-eeef-4fb7-83b6-6e96b334719b\" , \"override_type\" : \"create\" , \"mode\" : \"workbench\" , \"product_column_name\" : null , \"location_column_name\" : null , \"value_column_name\" : null , \"creation_time\" : \"2022-04-25T22:17:22.563620+00:00\" , \"is_active\" : true , \"desired_is_active\" : true , \"last_update\" : \"2022-04-25T22:17:30.766706+00:00\" , \"creation_user\" : \"someone@youdelivers.com\" , \"last_updated_user\" : \"someone@youdelivers.com\" , \"reason\" : \"other\" , \"description\" : \"\" , \"min_affected_date\" : \"2022-04-28\" , \"max_affected_date\" : \"2022-05-17\" , \"number_clp_combination\" : 273 , \"number_rows\" : null , \"source\" : \"lde-ui\" , \"prediction_accuracy\" : null , \"override_accuracy\" : null }, ... ] For our purpose, we are only interested in the creation_time value. But just look what's there, endless possibilities for cool new features, right? Create LIAM m2m client Luminate Identy Access Management (LIAM) is the authentication and authorization service in the Luminate Platform. You are already logged in into the portal, so your identity is known to all services. But when we want to build a service accessing API's, it is not you accessing the APIs, but this service. This is what machine-to-machine clients (m2m client) are for in LIAM. So we can create new identities that we assign to services and give it any subset of roles and permissions that our own identy has. This is increasing security dramatically, as we can shape those permissions such that it is \"just enough\" to do the job. Through the \"scope\" we can limit which services can be accessed, so that even if this m2m client is leaked, it cannot be used for anything else that the anticipated use-case. We can create m2m clients in a self service in the Identity & Access application available in the app gallery. Access the Identity & Access application In the Identiy & Access application change to the \"Machines\" tab and with the \"+\" icon we can create a new m2m client for our workflow. Create a new m2m client using the \"+\" icon in the \"Machines\" tab In the pop-up give the m2m client a good name (that's hard, I know). As this is a shared environment, probably it is a good idea to append your name, so why not devcon-workshop-<yourname> . Note the Client ID and add a secret Note Don't forget to note the client secret and store it somewhere safe! (A password manager would be a good option) Copy the secret and store it somehwere safe Now we need to add the role to be able to access the LDE oeverrides API. This role is called lde-full-access , just start to type and select in the picker. Add the `lde-full-access` role That's it, we created a m2m client. Easy, right? Building the Workflow Now we now there is an API there is an API we have a m2m client to be able to access this API. Now we need something to actually call the API and trigger actions based on the results. That is exactly what the \"Workflow\" feature is for. Workflow in a nutshell Workflow is based on the Azure Logic Apps service. Using a domain specific language (DSL) based on json one can easily define workflows that connect all kinds of APIs, services and events. The documentation of the Azure Logic Apps DSL can be found here . We will make use of the DSL, but also use the no-code visual workflow editor in the Luminate Portal. Start the ALM application in the app gallery ALM in a nutshell The Application Lifecycle Management service (ALM) let's you create and maintain the lifecycle of applications you create on the Luminate Platform. An application consists of multiple modules, and each module consists of several resources. In our case, the only available resource type is Workflow. We have one application for our workshop and every participant will create their own module in which they can build one or more workflows. Click on the DevCon22 Workshop application In the module list overview of the DevCon 22 Workshop click on \"Add Module\" As every participant creates their own module, let's include our name in the module name, why not YOURNAME-workshop Here you can leave everything like it is and just click on \"Create Module\" Now click on your newly created module As your module is brandnew it should be quite empty, so let's click on \"Add resource\" and select \"Workflow\" as the resource type Here you have to select a template which your workflow will be based on. It happens that \"LIAM M2M Authentication\" is a quite good starting point for our workshop...we are really lucky! Oh gosh, we have to choose another name, I thought maybe \"prediction_overrides_workflow\" is a pretty good one. Hey, our workflow should be created, let's jump right into the implementation and hit the edit icon! From Low-Code to Pro-Code Low-Code <> Pro-Code There is a low-code representation of your workflow, but there you have only limited customizability. So you will often have to switch between the low-code editor, and the pro-code editor. You can either enter the pro-code of the full workflow, or just the pro-code representation of a single node. In this section you will learn how to jump between those. Once you are in the low-code editor you should see the template which is just one HTTP action. When no node is selected (click on the white background), \"Switch to Pro-Code\" brings you to the pro-code representation of the global workflow. \"Switch to Workflow editor\" brings you back to the low-code representation. If you select a node (notice the \"Action Properties\" window in the top right) \"Switch to Pro-Code\" brings you to the pro-code representation of only the selected node. And \"Switch to Workflow Editor\" brings you back. Now you know everything about low-code, pro-code. If you just stay in the pro-code representation, I will not hate you ;-) The Save, Publish, Run, Check Cycle In this section we learn how we do the usual development cycle: change something, run it, check if the results are as expected (which barely ever is the case, right?) The development cyle is 1) Save 2) Publish 3) Run 4) Open Run History. If we do the cycle with the template we should see a failed first run. Surprise, the result is not quite what we expected, the run failed. Maybe you spot what might be wrong. Click on \"Close\" to go back to the workflow editor. Sure, we haven't entered the credentials from our m2m client yet. Let's do that and do the cycle. (Don't forget to hit \"Save Changes\" before.) Nice! We just debugged our workflow template! We are now ready for new challenges! Developing our first own action Time to develop our first own action. Now that we have the LIAM token, we can authenticate to the any Blue yonder API. So let's call the LDE Overrides API! Hit the plus sign after the \"Get LIAM Token\" and select \"Http\". Now we have a new Http action and rename it to Get Prediction Overrides. In the pro-code view, we see it is empty, let's fill it with the right content! How to use results from previous actions If you want to use results from previous actions, you can access them with body('NAME OF THE ACTION') , as everything in Workflow is json, you can easily access values from the json body using body('NAME OF THE ACTION')?['KEY'] and finally, if we want to actually return the value (as a string), we use the @ operator. So, this should return the key 'KEY' of the result of the 'NAME OF THE ACTION' action as as tring which can be directly embedded in another string: \"Hello @{body('NAME OF THE ACTION')?['KEY']}\" This is how the empty HTTP action looks like: { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"http://\" , \"method\" : \"\" , \"headers\" : {} }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } } Now, if we remember LDE Predictions Overrides API documentation in the API Catalog we saw that the request to get a list of predictions looks like this. If you don't have a photographic memory, here is what we saw there: curl -X 'GET' \\ 'https://api.jdadelivers.com/lde/prediction-overrides/v1/overrides' \\ -H 'accept: application/json' \\ -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJh********' So, the \"method\" seems to be \"GET\" and we can just enter it in the pro-code json. { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"http://\" , \"method\" : \"GET\" , \"headers\" : {} }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } } Can you figure out the rest? Sure! I help you a bit, the url we can again just copy&paste. For the \"headers\" we need to add some double quotes and commas to get it proper json, can you do that? this is how the \"headers\" should look like \"headers\" : { \"accept\" : \"application/json\" , \"Authorization\" : \"Bearer eyJ0eXAiOiJKV1QiLCJh********\" } Now, The \"Bearer\" token seems to be a bit tricky, isn't it? The actual token should not be that static string, but the LIAM token we created in the previous action 'Get LIAM Token'. It seems we need to embed a string from the result of a previous action, if only we would know how this works... If you want to cheat, solution is in here { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"https://api.jdadelivers.com/lde/prediction-overrides/v1/overrides\" , \"method\" : \"GET\" , \"headers\" : { \"accept\" : \"application/json\" , \"Authorization\" : \"Bearer @{body('Get LIAM Token')?['access_token']}\" } }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } } If jou came that far, just \"Save, Publish, Run\" and check the latest run if it succeded. It succeeded? Great! But there are a lot of prediction overrides right, and they are all outdated which is quite inconvenient because they clutter the results. But wasn't there a parameter in the api documentation to restrict the result to only prediction overrides created after some date? Can you figure that out and restrict the results to only overrides from yesterday? Hint Just check the LDE Overrides Prediction API doc and figure our how the url in the curl command changes when you add the \"minAffectedDate\" You think you got it? \"Save, Publish, Run\" and check the result! How many overrides do you have now in the response? Look behind you, a Three-Headed Monkey! (full solution in here) If you fail to get the json right, just copy&paste. This should work: { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"https://api.jdadelivers.com/lde/prediction-overrides/v1/overrides?minAffectedDate=2022-05-15\" , \"method\" : \"GET\" , \"headers\" : { \"accept\" : \"application/json\" , \"Authorization\" : \"Bearer @{body('Get LIAM Token')?['access_token']}\" } }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } } The Foreach Loop Now we have a list of all recent overrides predictions, but we are only interested in the newly created overrides predictions since the last run of the workflow. For this, the idea is to loop over all entries in the result of the previous HTTP action and filter for those entries, where the creation timestamp is greater than the last run of the workflow. We will later on trigger the workflow periodically every minute. So the timestamp should be greater then the current time 1 minute ago. Lets start with the loop over all entries. Just hit the plus sign after the \"Get Prediction Overrides\" action and select \"Foreach\". Let's rename it to \"Process Prediction Overrides\". Again pretty empty inside. Let's figure it out! So, this is how the structure looks like. { \"type\" : \"Foreach\" , \"actions\" : { \"action\" : { \"type\" : \"\" , \"runAfter\" : {} } }, \"foreach\" : \"\" , \"runAfter\" : { \"Get Prediction Overrides\" : [ \"Succeeded\" ] } } First we need to delete the empty action, otherwise the parser will complain. { \"type\" : \"Foreach\" , \"actions\" : { }, \"foreach\" : \"\" , \"runAfter\" : { \"Get Prediction Overrides\" : [ \"Succeeded\" ] } } Do you notice the foreach key? { \"type\" : \"Foreach\" , \"actions\" : { }, \"foreach\" : \"\" , \"runAfter\" : { \"Get Prediction Overrides\" : [ \"Succeeded\" ] } } The \"foreach\" key takes a list as a value...as the result of the previous action was a list of prediction overrides... maybe this works as before? (@ .. body... do you remember?). Try it out. Hint This is a hard one to figure out: Curly braces {} convert the data to a string. If you do not want to have a string, but the original data structure, you need to leave out the curly braces } . Hey, don't worry, took me several days to figure that out ;-) No, I don't get it, show me Pretty simple if you know how to do it. { \"type\": \"Foreach\", \"actions\": {}, \"foreach\": \"@body('Get Prediction Overrides')\", \"runAfter\": { \"Get Prediction Overrides\": [ \"Succeeded\" ] } } If all goes well, we should see a dummy iteration doing nothing for every prediction override.","title":"Workshop Walkthrough"},{"location":"workshop-walkthrough/#the-developer-portal","text":"","title":"The developer Portal"},{"location":"workshop-walkthrough/#login","text":"First we login into the developer portal: https://bylumuiportalplpna.azureedge.net/home/ You need to enter the realm, which is by-developer for the developer portal. Then login with your account credentials.","title":"Login"},{"location":"workshop-walkthrough/#navigate-the-portal","text":"After login you see the dashboard For now we are only interested in the \"App Gallery\" whoch shows all services and application that you have access to. The App Gallery view","title":"Navigate the portal"},{"location":"workshop-walkthrough/#the-api-catalog","text":"We now want to find out if there are APIs we can use to build our notification feature. For this we launch the API Catalog in the API Gallery Launch the API Catalog Inside the API Catalog, search for LDE. You then will find all the API exposed by LDE for you. You should find the \"Blue Yonder LDE Prediction Overrides v1\" API and click on it. Finding the LDE Prediction Overrides API in the API Catalog Once you clicked on it, you will be navigated to the API documentation. Documentation of the LDE Prediction Overrides API Here you can try our an API call by first clicking on the \"Try it out\" button and subsequently on the \"Execute\" button. You can try the API by clicking on \"Execute\" By exectuing this GET request we will get a list of all prediction overrides stored in the LDE instance. Hey, we have a list of all prediction overrides stored in the LDE instance! The response should look like this [ { \"processing_status\" : \"FINISHED\" , \"override_id\" : \"6caccdf4-eeef-4fb7-83b6-6e96b334719b\" , \"override_type\" : \"create\" , \"mode\" : \"workbench\" , \"product_column_name\" : null , \"location_column_name\" : null , \"value_column_name\" : null , \"creation_time\" : \"2022-04-25T22:17:22.563620+00:00\" , \"is_active\" : true , \"desired_is_active\" : true , \"last_update\" : \"2022-04-25T22:17:30.766706+00:00\" , \"creation_user\" : \"someone@youdelivers.com\" , \"last_updated_user\" : \"someone@youdelivers.com\" , \"reason\" : \"other\" , \"description\" : \"\" , \"min_affected_date\" : \"2022-04-28\" , \"max_affected_date\" : \"2022-05-17\" , \"number_clp_combination\" : 273 , \"number_rows\" : null , \"source\" : \"lde-ui\" , \"prediction_accuracy\" : null , \"override_accuracy\" : null }, ... ] For our purpose, we are only interested in the creation_time value. But just look what's there, endless possibilities for cool new features, right?","title":"The API Catalog"},{"location":"workshop-walkthrough/#create-liam-m2m-client","text":"Luminate Identy Access Management (LIAM) is the authentication and authorization service in the Luminate Platform. You are already logged in into the portal, so your identity is known to all services. But when we want to build a service accessing API's, it is not you accessing the APIs, but this service. This is what machine-to-machine clients (m2m client) are for in LIAM. So we can create new identities that we assign to services and give it any subset of roles and permissions that our own identy has. This is increasing security dramatically, as we can shape those permissions such that it is \"just enough\" to do the job. Through the \"scope\" we can limit which services can be accessed, so that even if this m2m client is leaked, it cannot be used for anything else that the anticipated use-case. We can create m2m clients in a self service in the Identity & Access application available in the app gallery. Access the Identity & Access application In the Identiy & Access application change to the \"Machines\" tab and with the \"+\" icon we can create a new m2m client for our workflow. Create a new m2m client using the \"+\" icon in the \"Machines\" tab In the pop-up give the m2m client a good name (that's hard, I know). As this is a shared environment, probably it is a good idea to append your name, so why not devcon-workshop-<yourname> . Note the Client ID and add a secret Note Don't forget to note the client secret and store it somewhere safe! (A password manager would be a good option) Copy the secret and store it somehwere safe Now we need to add the role to be able to access the LDE oeverrides API. This role is called lde-full-access , just start to type and select in the picker. Add the `lde-full-access` role That's it, we created a m2m client. Easy, right?","title":"Create LIAM m2m client"},{"location":"workshop-walkthrough/#building-the-workflow","text":"Now we now there is an API there is an API we have a m2m client to be able to access this API. Now we need something to actually call the API and trigger actions based on the results. That is exactly what the \"Workflow\" feature is for. Workflow in a nutshell Workflow is based on the Azure Logic Apps service. Using a domain specific language (DSL) based on json one can easily define workflows that connect all kinds of APIs, services and events. The documentation of the Azure Logic Apps DSL can be found here . We will make use of the DSL, but also use the no-code visual workflow editor in the Luminate Portal. Start the ALM application in the app gallery ALM in a nutshell The Application Lifecycle Management service (ALM) let's you create and maintain the lifecycle of applications you create on the Luminate Platform. An application consists of multiple modules, and each module consists of several resources. In our case, the only available resource type is Workflow. We have one application for our workshop and every participant will create their own module in which they can build one or more workflows. Click on the DevCon22 Workshop application In the module list overview of the DevCon 22 Workshop click on \"Add Module\" As every participant creates their own module, let's include our name in the module name, why not YOURNAME-workshop Here you can leave everything like it is and just click on \"Create Module\" Now click on your newly created module As your module is brandnew it should be quite empty, so let's click on \"Add resource\" and select \"Workflow\" as the resource type Here you have to select a template which your workflow will be based on. It happens that \"LIAM M2M Authentication\" is a quite good starting point for our workshop...we are really lucky! Oh gosh, we have to choose another name, I thought maybe \"prediction_overrides_workflow\" is a pretty good one. Hey, our workflow should be created, let's jump right into the implementation and hit the edit icon!","title":"Building the Workflow"},{"location":"workshop-walkthrough/#from-low-code-to-pro-code","text":"Low-Code <> Pro-Code There is a low-code representation of your workflow, but there you have only limited customizability. So you will often have to switch between the low-code editor, and the pro-code editor. You can either enter the pro-code of the full workflow, or just the pro-code representation of a single node. In this section you will learn how to jump between those. Once you are in the low-code editor you should see the template which is just one HTTP action. When no node is selected (click on the white background), \"Switch to Pro-Code\" brings you to the pro-code representation of the global workflow. \"Switch to Workflow editor\" brings you back to the low-code representation. If you select a node (notice the \"Action Properties\" window in the top right) \"Switch to Pro-Code\" brings you to the pro-code representation of only the selected node. And \"Switch to Workflow Editor\" brings you back. Now you know everything about low-code, pro-code. If you just stay in the pro-code representation, I will not hate you ;-)","title":"From Low-Code to Pro-Code"},{"location":"workshop-walkthrough/#the-save-publish-run-check-cycle","text":"In this section we learn how we do the usual development cycle: change something, run it, check if the results are as expected (which barely ever is the case, right?) The development cyle is 1) Save 2) Publish 3) Run 4) Open Run History. If we do the cycle with the template we should see a failed first run. Surprise, the result is not quite what we expected, the run failed. Maybe you spot what might be wrong. Click on \"Close\" to go back to the workflow editor. Sure, we haven't entered the credentials from our m2m client yet. Let's do that and do the cycle. (Don't forget to hit \"Save Changes\" before.) Nice! We just debugged our workflow template! We are now ready for new challenges!","title":"The Save, Publish, Run, Check Cycle"},{"location":"workshop-walkthrough/#developing-our-first-own-action","text":"Time to develop our first own action. Now that we have the LIAM token, we can authenticate to the any Blue yonder API. So let's call the LDE Overrides API! Hit the plus sign after the \"Get LIAM Token\" and select \"Http\". Now we have a new Http action and rename it to Get Prediction Overrides. In the pro-code view, we see it is empty, let's fill it with the right content! How to use results from previous actions If you want to use results from previous actions, you can access them with body('NAME OF THE ACTION') , as everything in Workflow is json, you can easily access values from the json body using body('NAME OF THE ACTION')?['KEY'] and finally, if we want to actually return the value (as a string), we use the @ operator. So, this should return the key 'KEY' of the result of the 'NAME OF THE ACTION' action as as tring which can be directly embedded in another string: \"Hello @{body('NAME OF THE ACTION')?['KEY']}\" This is how the empty HTTP action looks like: { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"http://\" , \"method\" : \"\" , \"headers\" : {} }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } } Now, if we remember LDE Predictions Overrides API documentation in the API Catalog we saw that the request to get a list of predictions looks like this. If you don't have a photographic memory, here is what we saw there: curl -X 'GET' \\ 'https://api.jdadelivers.com/lde/prediction-overrides/v1/overrides' \\ -H 'accept: application/json' \\ -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJh********' So, the \"method\" seems to be \"GET\" and we can just enter it in the pro-code json. { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"http://\" , \"method\" : \"GET\" , \"headers\" : {} }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } } Can you figure out the rest? Sure! I help you a bit, the url we can again just copy&paste. For the \"headers\" we need to add some double quotes and commas to get it proper json, can you do that? this is how the \"headers\" should look like \"headers\" : { \"accept\" : \"application/json\" , \"Authorization\" : \"Bearer eyJ0eXAiOiJKV1QiLCJh********\" } Now, The \"Bearer\" token seems to be a bit tricky, isn't it? The actual token should not be that static string, but the LIAM token we created in the previous action 'Get LIAM Token'. It seems we need to embed a string from the result of a previous action, if only we would know how this works... If you want to cheat, solution is in here { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"https://api.jdadelivers.com/lde/prediction-overrides/v1/overrides\" , \"method\" : \"GET\" , \"headers\" : { \"accept\" : \"application/json\" , \"Authorization\" : \"Bearer @{body('Get LIAM Token')?['access_token']}\" } }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } } If jou came that far, just \"Save, Publish, Run\" and check the latest run if it succeded. It succeeded? Great! But there are a lot of prediction overrides right, and they are all outdated which is quite inconvenient because they clutter the results. But wasn't there a parameter in the api documentation to restrict the result to only prediction overrides created after some date? Can you figure that out and restrict the results to only overrides from yesterday? Hint Just check the LDE Overrides Prediction API doc and figure our how the url in the curl command changes when you add the \"minAffectedDate\" You think you got it? \"Save, Publish, Run\" and check the result! How many overrides do you have now in the response? Look behind you, a Three-Headed Monkey! (full solution in here) If you fail to get the json right, just copy&paste. This should work: { \"type\" : \"Http\" , \"inputs\" : { \"uri\" : \"https://api.jdadelivers.com/lde/prediction-overrides/v1/overrides?minAffectedDate=2022-05-15\" , \"method\" : \"GET\" , \"headers\" : { \"accept\" : \"application/json\" , \"Authorization\" : \"Bearer @{body('Get LIAM Token')?['access_token']}\" } }, \"runAfter\" : { \"Get LIAM Token\" : [ \"Succeeded\" ] } }","title":"Developing our first own action"},{"location":"workshop-walkthrough/#the-foreach-loop","text":"Now we have a list of all recent overrides predictions, but we are only interested in the newly created overrides predictions since the last run of the workflow. For this, the idea is to loop over all entries in the result of the previous HTTP action and filter for those entries, where the creation timestamp is greater than the last run of the workflow. We will later on trigger the workflow periodically every minute. So the timestamp should be greater then the current time 1 minute ago. Lets start with the loop over all entries. Just hit the plus sign after the \"Get Prediction Overrides\" action and select \"Foreach\". Let's rename it to \"Process Prediction Overrides\". Again pretty empty inside. Let's figure it out! So, this is how the structure looks like. { \"type\" : \"Foreach\" , \"actions\" : { \"action\" : { \"type\" : \"\" , \"runAfter\" : {} } }, \"foreach\" : \"\" , \"runAfter\" : { \"Get Prediction Overrides\" : [ \"Succeeded\" ] } } First we need to delete the empty action, otherwise the parser will complain. { \"type\" : \"Foreach\" , \"actions\" : { }, \"foreach\" : \"\" , \"runAfter\" : { \"Get Prediction Overrides\" : [ \"Succeeded\" ] } } Do you notice the foreach key? { \"type\" : \"Foreach\" , \"actions\" : { }, \"foreach\" : \"\" , \"runAfter\" : { \"Get Prediction Overrides\" : [ \"Succeeded\" ] } } The \"foreach\" key takes a list as a value...as the result of the previous action was a list of prediction overrides... maybe this works as before? (@ .. body... do you remember?). Try it out. Hint This is a hard one to figure out: Curly braces {} convert the data to a string. If you do not want to have a string, but the original data structure, you need to leave out the curly braces } . Hey, don't worry, took me several days to figure that out ;-) No, I don't get it, show me Pretty simple if you know how to do it. { \"type\": \"Foreach\", \"actions\": {}, \"foreach\": \"@body('Get Prediction Overrides')\", \"runAfter\": { \"Get Prediction Overrides\": [ \"Succeeded\" ] } } If all goes well, we should see a dummy iteration doing nothing for every prediction override.","title":"The Foreach Loop"}]}